---
description: "Requirements Analysis Stage - ユーザー要求を包括的な要件仕様書に変換"
version: "2.0.0"
author: ["AnijaaaPan", "shouta0715"]
created: "2025-01-28"
updated: "2025-01-28"
category: "analysis"
tags:
  [
    "requirements",
    "analysis",
    "smart-criteria",
    "moscow",
    "claude-code-optimized",
  ]
stage: 1
prerequisite: "Clear user requirements description"
duration: "2-3 minutes"
output: ".tmp/step-1-requirements.md"
optimization: "Claude Code Best Practices + Japanese Excellence"
---

# 📋 要件分析ステージ

**ユーザーの要求を実装可能な包括的要件仕様書に変換します。**

Claude Codeのベストプラクティスに基づき、曖昧な要求を具体的で測定可能な機能要件・非機能要件に分解し、開発チーム全体が理解できる明確な仕様書を作成します。

## 🎯 Claude Code 最適化ポイント

- **段階的詳細化**: 初期段階で概要を把握し、段階的に詳細を追加
- **コンテキスト効率**: 必要な情報を簡潔にまとめ、コンテキストウィンドウを効率的に使用
- **反復改善**: フィードバックループによる継続的な品質向上
- **書き直し戦略**: 不十分な結果の場合は積極的に書き直しを依頼

## 📝 使用法

```bash
/step-1-requirements "User authentication system with social login and 2FA"
/step-1-requirements "Real-time chat with file sharing and notifications"
/step-1-requirements "Product catalog with advanced search and filtering"
```

## 📋 入力・出力仕様

### 入力要件

- **User Requirements**: `$ARGUMENTS` - 実装したい機能の詳細説明
  - ✅ **Good**: "JWT認証、パスワードリセット、2FA、役割ベースアクセス制御を含む認証システム"
  - ❌ **Bad**: "ログイン機能"
  - 🎯 **Claude Code Optimized**: 「技術要件、性能目標、セキュリティ基準、ユーザーシナリオを明示した包括的な要求説明」

### 出力仕様

- **ファイル**: `.tmp/step-1-requirements.md`
- **フォーマット**: 構造化されたMarkdown文書
- **内容**: 機能要件、非機能要件、制約、成功基準

## 🎯 分析目標

### 核心分析領域

1. **🎯 問題定義**
   - 解決すべき具体的な課題は何か？
   - なぜこのソリューションが必要なのか？
   - 主要ステークホルダーは誰か？
   - ビジネス価値と優先度は？

2. **⚙️ 機能要件**
   - 明示的要件（ユーザーが直接述べた内容）
   - 暗黙的要件（業界標準、慣習）
   - ユーザーワークフローと操作手順
   - エッジケースと例外処理

3. **🚀 非機能要件**
   - パフォーマンス目標（ページロード時間、API応答速度）
   - セキュリティ要件（認証、認可、データ保護）
   - アクセシビリティ基準（WCAG 2.1準拠）
   - 互換性（ブラウザ、デバイス、画面サイズ）

4. **🔗 統合ポイント**
   - 既存システムとの依存関係
   - 外部API要件と制約
   - データソースと形式
   - @package/ui コンポーネントの活用計画

## 📝 Requirements Template

````markdown
# 要件定義書 - [プロジェクト名]

**作成日**: YYYY-MM-DD  
**バージョン**: 1.0  
**ステータス**: Draft

## 1. エグゼクティブサマリー

### 1.1 目的

[プロジェクトの目的と背景]

### 1.2 スコープ

[プロジェクトの範囲と境界]

### 1.3 ステークホルダー

- プライマリユーザー: [詳細]
- セカンダリユーザー: [詳細]
- 管理者: [詳細]

## 2. 機能要件

### 2.1 ユーザーストーリー

| ID   | As a... | I want to... | So that... | Priority |
| ---- | ------- | ------------ | ---------- | -------- |
| US01 | [Role]  | [Action]     | [Benefit]  | High     |

### 2.2 機能一覧

#### 必須機能 (MVP)

- [ ] 機能1: [詳細説明]
- [ ] 機能2: [詳細説明]

#### 拡張機能 (Phase 2)

- [ ] 機能A: [詳細説明]
- [ ] 機能B: [詳細説明]

## 3. 非機能要件

### 3.1 パフォーマンス

- ページロード時間: < 3秒
- API レスポンス: < 200ms
- 同時接続数: 1000ユーザー

### 3.2 セキュリティ

- 認証方式: [JWT/OAuth/etc]
- データ暗号化: [要件]
- セキュリティヘッダー: [CSP, CORS等]

### 3.3 ユーザビリティ

- レスポンシブデザイン対応
- キーボードナビゲーション
- スクリーンリーダー対応

### 3.4 技術要件

- ブラウザサポート: Chrome 90+, Firefox 88+, Safari 14+
- Node.js: 18.x以上
- フレームワーク: Next.js 15+

## 4. UI/UXコンポーネント要件

### 4.1 @package/ui 利用可能コンポーネント

- Button, Card, Modal等の既存コンポーネント
- [利用予定のコンポーネントリスト]

### 4.2 カスタムコンポーネント要件

- [コンポーネント名]: [必要な理由と仕様]

### 4.3 デザインシステム

- カラーパレット: [定義]
- タイポグラフィ: [定義]
- スペーシング: [定義]

## 5. データ要件

### 5.1 データモデル

```typescript
interface User {
  id: string;
  email: string;
  // ...
}
```
````

### 5.2 API エンドポイント

| Method | Endpoint   | Description  | Request | Response |
| ------ | ---------- | ------------ | ------- | -------- |
| GET    | /api/users | ユーザー一覧 | -       | User[]   |

### 5.3 モックデータ戦略

- 開発フェーズでは静的JSONファイルを使用
- MSW (Mock Service Worker) でAPIモック

## 6. 制約事項

### 6.1 技術的制約

- TypeScript必須（any型禁止）
- 関数型プログラミング優先
- クラスベースコンポーネント禁止

### 6.2 リソース制約

- 開発期間: [期間]
- チームサイズ: [人数]
- 予算: [該当する場合]

## 7. 成功基準

### 7.1 定量的指標

- [ ] 全機能テストのパス率 100%
- [ ] Lighthouse スコア 90以上
- [ ] TypeScript エラー 0件

### 7.2 定性的指標

- [ ] ユーザビリティテストの完了
- [ ] アクセシビリティ監査のパス
- [ ] セキュリティ監査のパス

## 8. リスクと軽減策

| リスク    | 影響度 | 発生確率 | 軽減策 |
| --------- | ------ | -------- | ------ |
| [リスク1] | High   | Medium   | [対策] |

## 9. 依存関係

### 9.1 外部依存

- 外部API: [詳細]
- サードパーティライブラリ: [詳細]

### 9.2 内部依存

- 既存システム: [詳細]
- 共有コンポーネント: [詳細]

## 10. 次のステップ

- [ ] ステークホルダーレビュー
- [ ] 技術設計フェーズへ移行
- [ ] プロトタイプ作成

````

## 🚀 実行手順

### ステップ1: 準備作業
```bash
# .tmpディレクトリの作成
mkdir -p .tmp
```

### ステップ2: 要求分析
- **📖 要求の深堀り**: ユーザー説明の背景と文脈を理解
- **🔍 暗黙要件の抽出**: 業界標準やベストプラクティスを適用
- **⚖️ 実現可能性評価**: 技術的制約とリソース制約を検討
- **🎯 優先度設定**: MoSCoW方式（Must/Should/Could/Won't）で分類

### ステップ3: 構造化文書作成
- **📋 テンプレート適用**: 標準テンプレートに基づく体系的記述
- **📊 定量化**: 可能な限り数値目標を設定
- **🔗 関連性確保**: 各要件の相互関係を明確化
- **📝 レビュー最適化**: ステークホルダーが理解しやすい形式

### ステップ4: 品質保証
- **✅ 完全性チェック**: 漏れなくダブりなく（MECE）
- **🎯 実現可能性検証**: 技術的・リソース的実現性
- **📏 測定可能性確認**: 成功基準の定量化度合い

## 🚨 エラーハンドリング

### よくある問題と対策

| 問題 | 原因 | 対処法 |
|------|------|--------|
| 要求が曖昧すぎる | 情報不足 | 具体的な使用例を要求者に確認 |
| 技術的実現性が不明 | 新技術・複雑な要件 | 技術調査タスクを別途計画 |
| ステークホルダー不明 | 要求元の整理不足 | 影響範囲と関係者を明確化 |
| 非機能要件の欠如 | 機能面のみ注目 | 性能・セキュリティ等を必須項目化 |

### 品質改善ループ

```bash
# 1. 不十分な要件書が生成された場合
/step-1-requirements "より詳細で具体的な要求説明"

# 2. 段階的詳細化（必要に応じて）
# まず基本要件を作成 → 詳細を段階的に追加
```

## 💡 要件定義のベストプラクティス

### SMART+ 原則 (日本語版 Claude Code 最適化)
- **S確実性 (Specific)**: 曖昧さを排除し、具体的で明確な記述
- **M測定性 (Measurable)**: 数値的に測定可能な成功基準とKPI
- **A実現性 (Achievable)**: 現実的な技術的制約とリソース制約を考慮
- **R関連性 (Relevant)**: ビジネス価値とユーザー価値に直結
- **T時限性 (Time-bound)**: 明確な期限と優先度マトリックス
- **+テスト可能性 (Testable)**: 自動テストで検証可能な形で記述

### ユーザー中心設計
- **🎯 ユーザー価値優先**: 技術より価値に焦点
- **📱 ユースケース具体化**: 実際の利用シーンを詳述
- **🧑‍💻 ペルソナ設定**: 想定ユーザーを明確に定義
- **🔄 フィードバックループ**: 継続的な要件調整を計画

### 段階的詳細化アプローチ
- **🚀 MVP定義**: 最小実行可能な機能セット
- **📈 拡張計画**: Phase 2以降の機能拡張
- **🔗 依存関係管理**: 機能間の関係性を明確化
- **📝 トレーサビリティ**: 各要件に一意のIDとバージョン管理

## 📊 出力品質指標 (Claude Code ベストプラクティス準拠)

### 要件書のコア品質指標
- [ ] **完全性 & MECE原則**: 漏れなくダブりなく全要素を網羅
- [ ] **一貫性 & 矛盾解消**: 要件間のコンフリクトを事前に特定・解決
- [ ] **実現可能性 & リスク評価**: 技術的制約とリソース制約を猴資
- [ ] **測定可能性 & KPI**: 定量的成功基準と検証方法を明示
- [ ] **優先度マトリックス**: MoSCoW分析とビジネスインパクト評価

### Claude Code 特化最適化
- [ ] **@package/ui 活用計画**: 既存コンポーネントの網羅的調査と活用戦略
- [ ] **コンテキスト効率**: 簡潔で人間が読みやすい形式で記述
- [ ] **反復改善対応**: フィードバックループでの継続的品質向上を考慮
- [ ] **段階的詳細化**: MVPから拡張機能へのスムーズな進化計画

### 次ステージ連携準備度
- [ ] **技術設計情報**: アーキテクチャ設計に必要な全情報を提供
- [ ] **ステークホルダー合意**: 主要関係者のレビューと承認が完了
- [ ] **優先度コンセンサス**: 実装順序とリソース配分が合意済み
- [ ] **制約条件明確化**: 技術的・ビジネス的制約と前提条件を明文化
````
